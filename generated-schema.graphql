# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregatePost {
  count: Int!
}

input AuthInput {
  email: String!
  password: String!
}

type AuthPayload {
  token: String!
  user: User
}

type BatchPayload {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  id: String!
  name: String!
  posts(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
}

input CategoryCreateInput {
  id: String
  name: String!
  posts: PostCreateManyWithoutCategoriesInput
}

input CategoryCreateManyWithoutPostsInput {
  connect: [CategoryWhereUniqueInput!]
  create: [CategoryCreateWithoutPostsInput!]
}

input CategoryCreateWithoutPostsInput {
  id: String
  name: String!
}

enum CategoryDistinctFieldEnum {
  id
  name
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryOrderByInput {
  id: SortOrder
  name: SortOrder
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
}

input CategoryUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyWithoutPostsInput {
  connect: [CategoryWhereUniqueInput!]
  create: [CategoryCreateWithoutPostsInput!]
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutPostsInput!]
  updateMany: [CategoryUpdateManyWithWhereNestedInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutPostsInput!]
}

input CategoryUpdateManyWithWhereNestedInput {
  data: CategoryUpdateManyDataInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateWithoutPostsDataInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateWithWhereUniqueWithoutPostsInput {
  data: CategoryUpdateWithoutPostsDataInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpsertWithWhereUniqueWithoutPostsInput {
  create: CategoryCreateWithoutPostsInput!
  update: CategoryUpdateWithoutPostsDataInput!
  where: CategoryWhereUniqueInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  posts: PostListRelationFilter
}

input CategoryWhereUniqueInput {
  id: String
  name: String
}

type Comment {
  id: String!
  message: String
  postId: String!
  posts: Post!
  users(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]
}

input CommentCreateManyWithoutPostsInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostsInput!]
}

input CommentCreateManyWithoutUsersInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutUsersInput!]
}

input CommentCreateWithoutPostsInput {
  id: String
  message: String
  users: UserCreateManyWithoutCommentsInput
}

input CommentCreateWithoutUsersInput {
  id: String
  message: String
  posts: PostCreateOneWithoutCommentsInput!
}

enum CommentDistinctFieldEnum {
  id
  message
  postId
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentOrderByInput {
  id: SortOrder
  message: SortOrder
  postId: SortOrder
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  id: StringFilter
  message: StringNullableFilter
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  postId: StringFilter
}

input CommentUpdateManyDataInput {
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
}

input CommentUpdateManyWithoutPostsInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutPostsInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostsInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostsInput!]
}

input CommentUpdateManyWithoutUsersInput {
  connect: [CommentWhereUniqueInput!]
  create: [CommentCreateWithoutUsersInput!]
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUsersInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  data: CommentUpdateManyDataInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateWithoutPostsDataInput {
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  users: UserUpdateManyWithoutCommentsInput
}

input CommentUpdateWithoutUsersDataInput {
  id: StringFieldUpdateOperationsInput
  message: NullableStringFieldUpdateOperationsInput
  posts: PostUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutPostsInput {
  data: CommentUpdateWithoutPostsDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutUsersInput {
  data: CommentUpdateWithoutUsersDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutPostsInput {
  create: CommentCreateWithoutPostsInput!
  update: CommentUpdateWithoutPostsDataInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutUsersInput {
  create: CommentCreateWithoutUsersInput!
  update: CommentUpdateWithoutUsersDataInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  id: StringFilter
  message: StringNullableFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  postId: StringFilter
  posts: PostWhereInput
  users: UserListRelationFilter
}

input CommentWhereUniqueInput {
  id: String
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  createPost(data: PostCreateInput!): Post!
  createUser(data: UserCreateInput!): User!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyPost(where: PostWhereInput): BatchPayload!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteUser(where: UserWhereUniqueInput!): User
  login(login: AuthInput!): AuthPayload!
  publishPost(id: String!): Post
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

"""encript password in scalar type"""
scalar Password

type Post {
  author: User!
  authorId: String!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryDistinctFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentDistinctFieldEnum!], orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]
  content: String!
  createdAt: Timestamp!
  id: String!
  published: Boolean!
  title: String!
}

input PostCreateInput {
  author: UserCreateOneWithoutPostsInput!
  categories: CategoryCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostsInput
  content: String!
  createdAt: Timestamp
  id: String
  published: Boolean
  title: String!
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateManyWithoutCategoriesInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutCategoriesInput!]
}

input PostCreateOneWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
}

input PostCreateWithoutAuthorInput {
  categories: CategoryCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostsInput
  content: String!
  createdAt: Timestamp
  id: String
  published: Boolean
  title: String!
}

input PostCreateWithoutCategoriesInput {
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostsInput
  content: String!
  createdAt: Timestamp
  id: String
  published: Boolean
  title: String!
}

input PostCreateWithoutCommentsInput {
  author: UserCreateOneWithoutPostsInput!
  categories: CategoryCreateManyWithoutPostsInput
  content: String!
  createdAt: Timestamp
  id: String
  published: Boolean
  title: String!
}

enum PostDistinctFieldEnum {
  authorId
  content
  createdAt
  id
  published
  title
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  authorId: StringFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  published: BoolFilter
  title: StringFilter
}

input PostUpdateInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  categories: CategoryUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input PostUpdateManyDataInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithWhereNestedInput {
  data: PostUpdateManyDataInput!
  where: PostScalarWhereInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  connect: PostWhereUniqueInput
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
}

input PostUpdateWithoutAuthorDataInput {
  categories: CategoryUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input PostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  categories: CategoryUpdateManyWithoutPostsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput!
  update: PostUpdateWithoutCommentsDataInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserWhereInput
  authorId: StringFilter
  categories: CategoryListRelationFilter
  comments: CommentListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  title: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

type Profile {
  bio: String!
  id: String!
  user: User!
  userId: String!
}

input ProfileCreateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
}

input ProfileCreateWithoutUserInput {
  bio: String!
  id: String
}

input ProfileUpdateOneWithoutUserInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateWithoutUserDataInput
  upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserDataInput {
  bio: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input ProfileUpsertWithoutUserInput {
  create: ProfileCreateWithoutUserInput!
  update: ProfileUpdateWithoutUserDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  bio: StringFilter
  id: StringFilter
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  user: UserWhereInput
  userId: StringFilter
}

input ProfileWhereUniqueInput {
  id: String
}

type Query {
  aggregatePost(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryDistinctFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  profile: User!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  publishEvent: Post!
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentDistinctFieldEnum!], orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]
  email: String!
  id: String!
  name: String!
  password: String!
  posts(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  profile: Profile
}

input UserCreateInput {
  email: String!
  name: String!
  password: Password!
}

input UserCreateManyWithoutCommentsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCommentsInput!]
}

input UserCreateOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
}

input UserCreateWithoutCommentsInput {
  email: String!
  id: String
  name: String!
  password: String!
  posts: PostCreateManyWithoutAuthorInput
  profile: ProfileCreateOneWithoutUserInput
}

input UserCreateWithoutPostsInput {
  comments: CommentCreateManyWithoutUsersInput
  email: String!
  id: String
  name: String!
  password: String!
  profile: ProfileCreateOneWithoutUserInput
}

enum UserDistinctFieldEnum {
  email
  id
  name
  password
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
}

input UserUpdateInput {
  comments: CommentUpdateManyWithoutUsersInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
}

input UserUpdateManyDataInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithoutCommentsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutCommentsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCommentsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCommentsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateWithoutCommentsDataInput {
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: ProfileUpdateOneWithoutUserInput
}

input UserUpdateWithoutPostsDataInput {
  comments: CommentUpdateManyWithoutUsersInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profile: ProfileUpdateOneWithoutUserInput
}

input UserUpdateWithWhereUniqueWithoutCommentsInput {
  data: UserUpdateWithoutCommentsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsDataInput!
}

input UserUpsertWithWhereUniqueWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  comments: CommentListRelationFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  posts: PostListRelationFilter
  profile: ProfileWhereInput
}

input UserWhereUniqueInput {
  email: String
  id: String
}
